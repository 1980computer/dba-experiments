// Generated by CoffeeScript 1.9.1
var Car, RoadStripes, Scenery, activateNetwork, detectCollision, end, endStripes, interval, labels, learningRate, moveStripes, network, newRandomCar, normalizeInput, normalizeOutput, removeObstacle, reset, resetStripes, road, start, startStripes, trainNetwork,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Framer.Defaults.RoadStripes = {
  backgroundColor: "",
  height: 2,
  numOfStripes: 40
};

RoadStripes = (function(superClass) {
  extend(RoadStripes, superClass);

  function RoadStripes(options) {
    var key, ref, value;
    if (options == null) {
      options = {};
    }
    ref = Framer.Defaults.RoadStripes;
    for (key in ref) {
      value = ref[key];
      options[key] = value;
    }
    RoadStripes.__super__.constructor.call(this, options);
    this._addStripes();
  }

  RoadStripes.prototype._addStripes = function() {
    var i, j, ref, results, stripe;
    results = [];
    for (i = j = 0, ref = this.numOfStripes; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      stripe = new Layer({
        width: (this.width - ((this.numOfStripes + 1) * 10)) / this.numOfStripes,
        height: this.height,
        backgroundColor: "yellow",
        parent: this
      });
      results.push(stripe.x = 10 + ((stripe.width + 10) * i));
    }
    return results;
  };

  RoadStripes.define("numOfStripes", {
    get: function() {
      return this._numOfStripes;
    },
    set: function(value) {
      return this._numOfStripes = value;
    }
  });

  RoadStripes.define("time", {
    get: function() {
      return this._time;
    },
    set: function(value) {
      return this._time = value;
    }
  });

  return RoadStripes;

})(Layer);

Framer.Defaults.Scenery = {
  backgroundColor: "",
  numOfStripes: 20
};

Scenery = (function(superClass) {
  extend(Scenery, superClass);

  function Scenery(options) {
    var key, ref, value;
    if (options == null) {
      options = {};
    }
    ref = Framer.Defaults.Scenery;
    for (key in ref) {
      value = ref[key];
      options[key] = value;
    }
    Scenery.__super__.constructor.call(this, options);
    this._addStripes();
  }

  Scenery.prototype._addStripes = function() {
    var i, j, ref, results, stripe;
    results = [];
    for (i = j = 0, ref = this.numOfStripes; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push(stripe = new Layer({
        x: (this.width / this.numOfStripes) * i,
        width: this.width / this.numOfStripes,
        height: this.height,
        backgroundColor: i % 2 === 0 ? this.colors[0] : this.colors[1],
        parent: this
      }));
    }
    return results;
  };

  Scenery.define("numOfStripes", {
    get: function() {
      return this._numOfStripes;
    },
    set: function(value) {
      return this._numOfStripes = value;
    }
  });

  Scenery.define("colors", {
    get: function() {
      return this._colors;
    },
    set: function(value) {
      return this._colors = value;
    }
  });

  return Scenery;

})(Layer);

Framer.Defaults.Car = {
  width: 48,
  borderRadius: 6,
  clip: true
};

Car = (function(superClass) {
  extend(Car, superClass);

  function Car(options) {
    var key, ref, value;
    if (options == null) {
      options = {};
    }
    ref = Framer.Defaults.Car;
    for (key in ref) {
      value = ref[key];
      if (options[key] == null) {
        options[key] = value;
      }
    }
    Car.__super__.constructor.call(this, options);
    this._addParts();
  }

  Car.prototype._addParts = function() {
    this.leftHeadlight = new Layer({
      midY: 0,
      midX: this.width,
      size: {
        width: 8,
        height: 8
      },
      borderRadius: 8 / 2,
      parent: this,
      name: "leftHeadlight",
      backgroundColor: "yellow"
    });
    this.rightHeadlight = new Layer({
      midY: this.height,
      midX: this.width,
      size: {
        width: 8,
        height: 8
      },
      borderRadius: 8 / 2,
      parent: this,
      name: "rightHeadlight",
      backgroundColor: "yellow"
    });
    this.leftTaillight = new Layer({
      midY: 0,
      midX: 0,
      size: {
        width: 8,
        height: 8
      },
      borderRadius: 8 / 2,
      parent: this,
      name: "leftTaillight",
      backgroundColor: "red"
    });
    this.rightTaillight = new Layer({
      midY: this.height,
      midX: 0,
      size: {
        width: 8,
        height: 8
      },
      borderRadius: 8 / 2,
      parent: this,
      name: "rightTaillight",
      backgroundColor: "red"
    });
    this.windshield = new Layer({
      maxX: this.width - 10,
      midY: this.height / 2,
      height: this.height - 4,
      width: 8,
      borderRadius: 2,
      parent: this,
      name: "windshield",
      backgroundColor: "#BDBDBD"
    });
    return this.backWindow = new Layer({
      x: 8,
      midY: this.height / 2,
      height: this.height - 4,
      width: 6,
      borderRadius: 1,
      parent: this,
      name: "windshield",
      backgroundColor: "#BDBDBD"
    });
  };

  return Car;

})(Layer);

network = new synaptic.Architect.Perceptron(3, 3, 3);

labels = {
  stay: [0, 0, 1],
  up: [0, 1, 0],
  down: [1, 0, 0]
};


/* 

Inputs i.e. "features"
- Time until collision
- Player's lane
- Car's lane

Each is calculated within activateNetwork function.

–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

Before starting the game, train the network with something 

Scenarios
1) Stayed in bottom lane, should have moved up
2) Moved up, should have stayed in bottom lane
3) Stayed in top lane, should have moved down
4) Moved to bottom lane, should have stayed up
 */

learningRate = .03;

normalizeInput = function(value, from, to) {
  return Utils.modulate(value, from, to, true);
};

normalizeOutput = function(output) {
  var i, j, len, value;
  for (i = j = 0, len = output.length; j < len; i = ++j) {
    value = output[i];
    output[i] = Math.round(value);
  }
  return output;
};

trainNetwork = function(inputs, target, iterations, learningRate) {
  var i, j, ref;
  for (i = j = 0, ref = iterations; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    network.activate(inputs);
    network.propagate(learningRate, target);
  }
};


/*

ARCHIVE

 * Initial training
 * 1) Stayed in bottom lane, should have moved up		
trainNetwork([Utils.randomNumber(.35, 1), 1, 1], labels.up, 20000, learningRate)
 * 2) Moved up, should have stayed in bottom lane
trainNetwork([Utils.randomNumber(.35, 1), Utils.randomNumber(.01, .99), 0], labels.stay, 20000, learningRate)
 * 3) Stayed in top lane, should have moved down
trainNetwork([Utils.randomNumber(.35, 1), 0, 0], labels.down, 20000, learningRate)
 * 4) Moved to bottom lane, should have stayed up
trainNetwork([Utils.randomNumber(.35, 1), Utils.randomNumber(.01, .99), 1], labels.stay, 20000, learningRate)
 * Bonus - Avoid weeving and stay in one lane as much as possible
trainNetwork([Utils.randomNumber(.35, 1), 0, 1], labels.stay, 20000, learningRate)
trainNetwork([Utils.randomNumber(.35, 1), 1, 0], labels.stay, 20000, learningRate)
 */

road = new Layer({
  height: 100,
  width: Screen.width,
  backgroundColor: "black"
});

road.center();

road.players = [];

road.cars = [];

removeObstacle = function(oldObstacle, player) {
  var j, len, newObstacles, obstacle, ref;
  newObstacles = [];
  ref = player.obstacles;
  for (j = 0, len = ref.length; j < len; j++) {
    obstacle = ref[j];
    if (obstacle !== oldObstacle) {
      newObstacles.push(obstacle);
    }
  }
  return player.obstacles = newObstacles;
};

road.stripes = new RoadStripes({
  midY: road.height / 2,
  width: road.width,
  parent: road,
  time: 10,
  name: "roadStripes"
});

road.stripes2 = new RoadStripes({
  x: Screen.width - 10,
  midY: road.height / 2,
  width: road.width,
  parent: road,
  time: 20,
  name: "roadStripes2"
});

endStripes = function() {
  this.x = Screen.width;
  return startStripes(this, 20);
};

startStripes = function(stripes, time) {
  stripes.animate({
    properties: {
      maxX: 0
    },
    curve: "linear",
    time: time
  });
  return stripes.on(Events.AnimationEnd, endStripes);
};

resetStripes = function() {
  this.x = Screen.width - 10;
  this.time = 20;
  return moveStripes(this);
};

moveStripes = function(stripes) {
  stripes.animate({
    properties: {
      maxX: 0
    },
    curve: "linear",
    time: stripes.time
  });
  return stripes.on(Events.AnimationEnd, resetStripes);
};

road.topLane = (road.height / 4) - road.stripes.height / 2;

road.bottomLane = road.height - (road.height / 4) + road.stripes.height / 2;

newRandomCar = function(suspect, cop) {
  var randomCar;
  randomCar = new Car({
    x: Screen.width,
    midY: Utils.randomChoice([road.topLane, road.bottomLane]),
    height: 24,
    backgroundColor: Utils.randomChoice(["#0D47A1", "#004D40", "#1B5E20", "#263238"]),
    parent: road
  });
  road.cars.push(randomCar);
  suspect.obstacles.push(randomCar);
  cop.obstacles.push(randomCar);
  randomCar.animate({
    properties: {
      maxX: 0
    },
    curve: "linear",
    time: Utils.randomNumber(3, 4)
  });
  return randomCar.once(Events.AnimationEnd, function() {
    return this.destroy();
  });
};

detectCollision = function(car, player) {
  if (player.x < car.x + car.width && player.x + player.width > car.x && player.y < car.y + car.height && player.height + player.y > car.y) {
    return true;
  } else {
    return false;
  }
};

activateNetwork = function(player) {
  var car, output, position;
  car = player.obstacles[0];
  player.timeUntilCollision = normalizeInput(car.x, [road.width, player.maxX], [1, 0]);
  player.lane = normalizeInput(player.midY, [road.topLane, road.bottomLane], [0, 1]);
  car.lane = normalizeInput(car.midY, [road.topLane, road.bottomLane], [0, 1]);
  output = normalizeOutput(network.activate([player.timeUntilCollision, player.lane, car.lane]));
  position = (function() {
    switch (false) {
      case !(_.isEqual(output, labels.up) && player.isAnimating === false && player.midY !== road.topLane):
        return player.animate({
          properties: {
            midY: road.topLane
          },
          time: player.timeUntilCollision < .35 ? .35 : player.timeUntilCollision,
          curve: "linear"
        });
      case !(_.isEqual(output, labels.down) && player.isAnimating === false && player.midY !== road.bottomLane):
        return player.animate({
          properties: {
            midY: road.bottomLane
          },
          time: player.timeUntilCollision < .35 ? .35 : player.timeUntilCollision,
          curve: "linear"
        });
    }
  })();
  if (car.maxX < player.x) {
    removeObstacle(car, player);
  }
  if (detectCollision(car, player) === true) {
    return end(car, player);
  }
};

interval = null;

start = function() {
  var cop, delay, i, j, siren, suspect;
  suspect = new Car({
    midX: Screen.width / 2,
    midY: Utils.randomChoice([road.topLane, road.bottomLane]),
    parent: road,
    height: 24,
    backgroundColor: "#B71C1C",
    name: "suspect"
  });
  suspect.obstacles = [];
  cop = new Car({
    maxX: suspect.x - 48,
    midY: Utils.randomChoice([road.topLane, road.bottomLane]),
    parent: road,
    height: 24,
    backgroundColor: "#212121",
    name: "cop"
  });
  cop.roof = new Layer({
    midX: (cop.width / 2) - 2,
    width: 8,
    height: cop.height,
    parent: cop,
    backgroundColor: "white"
  });
  cop.sirens = [];
  for (i = j = 0; j < 4; i = ++j) {
    siren = new Layer({
      midX: (cop.width / 2) - 2,
      y: 4 + (4 * i),
      width: 4,
      height: 4,
      backgroundColor: i < 2 ? "blue" : "red",
      parent: cop
    });
  }
  cop.obstacles = [];
  road.cars.push(suspect, cop);
  newRandomCar(suspect, cop);
  delay = 1;
  interval = Utils.interval(delay, function() {
    newRandomCar(suspect, cop);
    return delay = Utils.randomNumber(1, 2);
  });
  moveStripes(road.stripes);
  moveStripes(road.stripes2);
  return Framer.Loop.on("update", function() {
    this.eventHandler = arguments.callee;
    activateNetwork(suspect);
    return activateNetwork(cop);
  });
};

end = function(car, player) {
  var j, layer, len, ref, target, whichTarget;
  Framer.Loop.off("update", this.eventHandler);
  clearInterval(interval);
  interval = null;
  ref = road.cars;
  for (j = 0, len = ref.length; j < len; j++) {
    layer = ref[j];
    layer.animateStop();
  }
  road.stripes.off(Events.AnimationEnd, resetStripes);
  road.stripes2.off(Events.AnimationEnd, resetStripes);
  whichTarget = (function() {
    switch (false) {
      case !(player.lane === 1 && car.lane === 1):
        return target = labels.up;
      case !(player.lane > 0 && car.lane === 0):
        return target = labels.stay;
      case !(player.lane === 0 && car.lane === 0):
        return target = labels.down;
      case !(player.lane < 1 && car.lane === 1):
        return target = labels.stay;
    }
  })();
  trainNetwork([player.timeUntilCollision, player.lane, car.lane], target, 20000, .03);
  return Utils.delay(.5, function() {
    return reset();
  });
};

reset = function() {
  var car, j, len, ref;
  ref = road.cars;
  for (j = 0, len = ref.length; j < len; j++) {
    car = ref[j];
    car.destroy();
  }
  road.stripes.x = 0;
  road.stripes2.x = Screen.width - 10;
  road.stripes.time = 10;
  road.stripes2.time = 20;
  return start();
};
